# Review: 85507e9de4ef9d66

**Source:** coderabbitai
**Type:** review
**Original ID:** 3688864477
**Created:** None
**Severity:** MEDIUM
**Status:** SKIPPED

---

## Original Content

**Actionable comments posted: 57**

<details>
<summary>ðŸ¤– Fix all issues with AI agents</summary>

````
In `@apps/backend/agents/linear_validator.py`:
- Around line 909-919: In the current_version parsing block inside
linear_validator.py you return early when len(parts) < 2, so the subsequent
checks in that block (major = int(parts[0]) if len(parts) > 0 else 0, minor =
int(parts[1]) if len(parts) > 1 else 0, patch = int(parts[2]) if len(parts) > 2
else 0) are redundant; simplify by directly parsing major = int(parts[0]) and
minor = int(parts[1]) (since parts has at least 2 elements) and only
conditionally parse patch from parts[2] if len(parts) > 2, keeping the behavior
of returning f"{current_version} (version format unclear)" unchanged and
preserving any ValueError handling surrounding this try block.
- Around line 278-281: The branch that checks if "404" or "not found" is in
error_message incorrectly returns the raw issue_id when issue_id is present;
update it to return a formatted error message including the issue_id (e.g.,
"Ticket {issue_id} not found. Please verify the ticket ID.") instead of
returning issue_id directly, keeping the existing fallback "Ticket not found.
Please verify the ticket ID." when issue_id is falsy; locate the snippet using
the variables error_message and issue_id in this file and replace the return
expression accordingly.
- Around line 178-189: The custom class TimeoutError shadows Python's built-in
TimeoutError; rename it (e.g., ValidationTimeoutError) to avoid conflicts and
update all references; specifically rename class TimeoutError (which subclasses
ValidationError and defines __init__(self, issue_id: str, timeout_seconds:
float)) to ValidationTimeoutError, update any raise statements, exception
handlers (except TimeoutError), and type annotations/usages (including the usage
noted in the review) to the new name, and adjust the docstring to reflect the
new class name so imports/exports remain consistent.
- Around line 132-136: The import random is being done inside the retry block
where config.jitter is checked causing repeated imports; move the import to
module level by adding a single "import random" at the top of the file and
remove the inline "import random" in the jitter block so the code that modifies
delay (delay = delay * (0.5 + random.random())) uses the top-level module
instead; update any linter/unused-import checks accordingly and ensure no other
references rely on the in-block import.
- Around line 696-706: The current JSON extraction using json_match and regex
r"(\{.*?\})" fails on nested objects; update the extraction in the block around
json_match and json.loads to first try extracting a ```json``` code block
(json_match = re.search(r"```json...")) and if that fails, locate the first '{'
in response and iteratively scan forward counting brace depth until it returns
to zero to extract a balanced JSON substring, then call json.loads on that
substring, set result["issue_id"] and result["raw_response"] as before (preserve
the existing variables json_match, response, result, issue_id, raw_response) and
fall back to the original regex only if the balanced-brace extraction fails.

In `@apps/backend/tests/integration/test_linear_mcp.py`:
- Around line 82-104: The test test_linear_validation_agent_initialization
hardcodes the model string which couples the test to the current default; change
the assertion to compare agent.model against the module/class default instead of
a literal. Import the default constant (e.g., DEFAULT_MODEL) from
agents.linear_validator if available, or use LinearValidationAgent.DEFAULT_MODEL
(or another exported class attribute) in the assertion, otherwise assert a
looser property (non-empty string or expected prefix) to avoid failing when the
agent's default model changes.
- Around line 206-231: The test assertions expect colons in the timestamp but
the agent's _get_cache_key sanitizes colons to underscores in the
validation_timestamp, so update the expected values for key1, key2 and key3 to
match the implementation (e.g., "LIN-123:2024-01-18T10_00_00Z" instead of
"LIN-123:2024-01-18T10:00:00Z") so that assertions against
agent._get_cache_key(...) reflect the colon-to-underscore substitution performed
by _get_cache_key.

In `@apps/backend/tests/test_linear_validation.py`:
- Around line 362-373: Add a unit test that asserts HTTP 502 is treated as
transient by the is_transient_error checker: create a new test method (e.g.,
test_502_bad_gateway_is_transient) alongside the other tests in
test_linear_validation.py that calls is_transient_error(Exception("HTTP 502: Bad
Gateway")) and asserts True; this mirrors existing tests like
test_500_internal_server_error and test_503_service_unavailable and ensures the
"502" pattern in TRANSIENT_ERROR_PATTERNS is covered.
- Line 13: Remove the unused import of shutil from the test file
test_linear_validation.py; locate the import statement referencing shutil and
delete it (or if intended for future use, replace with a comment and add usage),
then run the tests/lint to confirm no references remain to the shutil symbol.
- Around line 269-278: The test expectation is wrong because
LinearValidationAgent._get_cache_key sanitizes colons in both the issue_id and
timestamp; update the assertion to match the implementation by expecting all
colons replaced with underscores (e.g., "LIN_123_2024-01-18T10_00_00Z") or
adjust the test to build the expected value by calling the same sanitization
logic; reference _get_cache_key and change the expected cache_key accordingly.
- Around line 248-256: The tests assume timestamps keep colons but
_get_cache_key (in linear_validator.py) sanitizes colons to underscores; update
the three tests (test_cache_key_format, test_cache_key_different_timestamps,
test_cache_key_with_colon_in_issue_id in
apps/backend/tests/test_linear_validation.py) to expect the sanitized form
(e.g., "LIN-123:2024-01-18T10_00_00Z") or alternatively change _get_cache_key to
not replace ':' if you prefer; keep the test expectations consistent with the
_get_cache_key behavior.

In
`@apps/frontend/apps/frontend/src/renderer/components/linear/components/index.ts`:
- Around line 1-6: This module that exports ValidationModal and LinearFilterBar
is placed in the wrong nested frontend folder; relocate the index.ts that
contains the exports (the file exporting ValidationModal and LinearFilterBar)
into the existing linear/components directory under the frontend renderer so it
matches the other Linear component files and remove the duplicate nested folder;
after moving, update any import paths referencing this index to point to the new
location and verify there are no remaining duplicate directories or broken
imports.

In `@apps/frontend/e2e/linear-dashboard.spec.ts`:
- Around line 46-50: Remove the redundant conditional around the assertion: drop
the if (ticketCount > 0) check and directly assert on the count returned from
page.locator('[data-testid="linear-ticket-item"]').count(); i.e. call
expect(ticketCount).toBeGreaterThan(0) using the ticketCount variable so the
test actually enforces "at least one ticket" without a tautological guard.
- Around line 79-85: Replace the fixed sleep with an event-based wait: instead
of await page.waitForTimeout(500) before asserting the filter badge, wait for
the badge locator to become visible using Playwright's waiting APIs (e.g., await
page.locator('[data-testid="filter-team"] .filter-badge').waitFor({ state:
'visible' }) or use await expect(page.locator('[data-testid="filter-team"]
.filter-badge')).toBeVisible({ timeout: <ms> })). Apply the same replacement for
the other occurrences on the test (the same pattern at lines referenced near 95,
109, and 135) so assertions no longer rely on waitForTimeout.
- Around line 389-400: The hardcoded timing assertion using Date.now() around
the click on '[data-testid="btn-validate-ticket"]' and waiting for
'[data-testid="validation-complete"]' is flaky; replace it with a deterministic
verification: either mock the backend response for the second validation call so
the test can assert cache behavior reliably, or (preferable) modify the
validation response to include a cache indicator and assert that
'[data-testid="validation-complete"]' response contains that cache-status flag
instead of measuring duration; if neither is possible remove the
duration/expect(duration).toBeLessThan(5000) check entirely and simply assert
that the second call completes (presence of
'[data-testid="validation-complete"]') and then click
'[data-testid="btn-cancel-validation"]' as before.

In `@apps/frontend/src/main/ipc-handlers/linear-handlers.ts`:
- Around line 624-739: The handler callback's validation parameter is typed as
any; define a specific interface (e.g., Validation with suggestedLabels?:
Array<{ name: string }>) and replace the any with that type in the
ipcMain.handle callback signature for
IPC_CHANNELS.LINEAR_UPDATE_TICKET_WITH_VALIDATION; update any local usages
(mapping suggestedLabels) to use the typed shape so suggestedLabels and its
items are recognized as optional and having name: string.
- Around line 554-582: The handler for IPC_CHANNELS.LINEAR_VALIDATE_TICKET
currently returns IPCResult<any>; replace the any with a concrete validation
result type (e.g., LinearValidationResult or ValidationResult) and update the
handler signature and return usages accordingly so the promise becomes
Promise<IPCResult<LinearValidationResult>>; locate the handler registered via
ipcMain.handle and the call to agentManager.validateLinearTicket to infer the
fields (success, data, error) and ensure the new type models them, and apply the
same typing change to the other handlers referenced (LINEAR_VALIDATE_BATCH and
LINEAR_UPDATE_TICKET_WITH_VALIDATION) so all three IPC handlers use the specific
validation result type rather than any.
- Around line 744-771: The cache-clear handler registered for
IPC_CHANNELS.LINEAR_CLEAR_CACHE builds cacheDir using process.env.HOME which is
undefined on Windows; change it to use os.homedir() (import os from 'os') when
constructing the path inside the ipcMain.handle async callback so the path
resolves cross-platform. Update the cacheDir construction in the
LINEAR_CLEAR_CACHE handler (and mirror the same replacement in
terminal-handlers.ts, worktree-handlers.ts, and terminal-store.ts where
process.env.HOME is used) to ensure correct home directory resolution on
Windows, macOS, and Linux.

In `@apps/frontend/src/preload/api/modules/linear-api.ts`:
- Around line 26-29: The signatures validateLinearTicketBatch and
updateLinearTicketWithValidation currently return Promise<IPCResult<any>> which
weakens type safety; define explicit result types (e.g., BatchValidationResult
and UpdateValidationResult or reuse/extend ValidationResult) and replace the any
occurrences with those types, update the IPCResult generic accordingly, and
export or import the new interfaces so callers and handlers (functions named
validateLinearTicketBatch and updateLinearTicketWithValidation) get proper typed
responses consistent with ValidationResult.

In `@apps/frontend/src/renderer/components/linear/components/index.ts`:
- Line 1: Remove the stale placeholder comment at the top of the file; since
components like LinearTicketDetail are implemented, delete the line "//
Placeholder exports - will be implemented in subtasks 4-2 and 4-4" (or replace
it with a short, accurate comment if needed) so the file no longer contains
outdated notes about future subtasks.

In `@apps/frontend/src/renderer/components/linear/components/LinearFilterBar.tsx`:
- Line 19: The import Loader2 in the LinearFilterBar component is unused; remove
the Loader2 import statement from
apps/frontend/src/renderer/components/linear/components/LinearFilterBar.tsx (the
symbol Loader2) so the component no longer contains an unused import and the
linter warning is resolved.
- Around line 479-485: The clear-search button in the LinearFilterBar component
is missing an explicit type and may default to "submit" inside a form; update
the button element within LinearFilterBar (the element with onClick={() =>
onSearchChange('')} and aria-label={t('linear.clearSearch')}) to include
type="button" to prevent unintended form submissions while preserving its
onClick behavior and styling.
- Around line 50-62: PRIORITY_OPTIONS currently contains hardcoded English
labels; replace each option's label property with a translation key (e.g.,
labelKey: 'linear.priority.noPriority', 'linear.priority.urgent', etc.) and
update the consumers of PRIORITY_OPTIONS (where the list is rendered/used â€”
referenced near uses of t(opt.label) in this component) to call t(opt.labelKey)
instead of using the plain label; ensure all new keys are added to the i18n
resource files and preserve the other option properties (value, icon, color,
bgColor) unchanged.
- Around line 348-375: The listbox lacks keyboard navigation and focusable
options; add keyboard support by introducing a focusedIndex state (e.g., const
[focusedIndex, setFocusedIndex] = useState<number | null>(null)) and keep refs
or use data-index attributes for option elements rendered in the items.map loop;
make each option div focusable (tabIndex={0}) and update its visual state when
index === focusedIndex, and attach a keyDown handler on the listbox wrapper
(role="listbox") to handle ArrowDown/ArrowUp (move focusedIndex, wrap at ends
and call .focus() on the target option), Enter/Space (invoke
handleSelect(item.value) for the focusedIndex), and Escape (call the existing
close handler or blur the listbox if available); ensure aria-selected remains
correct and consider setting aria-activedescendant to the active option id for
screen-reader support.

In
`@apps/frontend/src/renderer/components/linear/components/LinearTicketDetail.tsx`:
- Around line 216-221: The "View Full Validation" button in the
LinearTicketDetail component lacks an explicit type, which can cause it to act
as a submit in forms; update the button element that calls
setShowValidationModal and renders {t('linear:viewFullValidation')} inside
LinearTicketDetail.tsx to include type="button" so it behaves as a non-submit
control.
- Around line 163-181: The button in the LinearTicketDetail component is missing
an explicit type and will default to type="submit", causing unintended form
submissions; update the JSX for the button rendered in LinearTicketDetail (the
element using onClick={handleValidate}, disabled={isValidating},
aria-label={t('linear:validateTicket')}) to include type="button" so it will not
submit any parent form.
- Around line 100-126: In LinearTicketDetail.tsx, replace the non-semantic
div-based metadata list with proper semantic elements: change the container with
role="list" to a <ul> and each child with role="listitem" to an <li> (preserving
className, aria-label, and content), and keep conditional render logic for
ticket.assignee and ticket.project as-is; ensure styling and accessibility
attributes (e.g., aria-label="Ticket metadata") are moved to the <ul> and any
existing layout classes remain on the elements so
getStatusColor(ticket.state.type), getPriorityBadgeClass(ticket.priority),
ticket.assignee, ticket.project, and the createdAt date rendering continue to
work unchanged.
- Around line 4-6: Remove the unused imports useLinearStore and useToast from
LinearTicketDetail.tsx: locate the import line that brings in useLinearStore
from '../../../../stores/linear-store' and the import of useToast from
'../../../../hooks/use-toast' and delete those two named imports so only used
imports (e.g., ValidationModal) remain; ensure no other references to
useLinearStore or useToast exist in the LinearTicketDetail component and run a
typecheck/build to confirm import cleanup.

In
`@apps/frontend/src/renderer/components/linear/components/LinearTicketItem.tsx`:
- Around line 350-361: Replace the hardcoded screen-reader strings in the
LinearTicketItem component â€” currently rendered via the SrOnly elements
containing "Assigned to " and "Last updated " â€” with calls to the app's i18n
translation function (e.g., t('...')) and new translation keys (suggestions:
"linear.assignedTo" and "linear.lastUpdated") so the SrOnly text is localized;
update usages in the JSX around ticket.assignee and the updatedAt display to use
those translation keys instead of literal strings.
- Around line 236-254: The formatDate function currently returns hardcoded
English strings; change it to use the i18n translator (e.g. accept a t:
TFunction parameter or call useTranslation inside the component) and replace all
literal strings ("m ago", "h ago", "yesterday", "d ago", "w ago") with
translated keys using interpolation/pluralization (e.g. t('time.minutesAgo', {
count: mins }), t('time.yesterday'), etc.) so outputs are localized; then update
the place where formatDate is called in the LinearTicketItem component to pass
the t function (or call the new hook-based variant) so translations are
available at runtime.
- Around line 272-294: The container in LinearTicketItem currently uses a
non-interactive <div> with role="listitem", tabIndex and aria-selected which is
invalid; replace the outer div with a semantic interactive element (preferably a
<button>) or wrap the interactive button inside an <li> and make the parent a
proper <ul>/<ol>; move event handlers (handleClick, onClick, onToggleSelect,
onKeyDown) onto the button, remove aria-selected from the listitem (if you need
selection state on the button use aria-pressed or aria-checked as appropriate),
and keep titleId/metaId on the button via aria-labelledby/aria-describedby while
preserving isSelected styling via className.

In
`@apps/frontend/src/renderer/components/linear/components/LinearTicketList.tsx`:
- Around line 110-118: Replace the non-semantic divs used as status regions with
semantic output elements: locate the JSX elements in LinearTicketList that
render the loading and other status regions (the divs with role="status"
aria-live="polite" aria-busy and aria-label attributes, including the block that
renders TicketItemSkeleton via Array.from and the similar blocks around lines
referenced in the review) and change them to use <output> while preserving all
accessibility attributes (aria-live, aria-busy, aria-label) and className
values; ensure the component still returns valid JSX and that any tests or
styles expecting a div are updated to accept an output element where needed.
- Around line 122-150: The early return in LinearTicketList when isLoadingMore
is true removes the loadMoreTriggerRef and breaks the IntersectionObserver;
remove this entire conditional return and let the main render path handle
isLoadingMore so the tickets.map and the element referenced by
loadMoreTriggerRef remain in the DOM, and keep the existing loading indicator
logic inside the main return (ensure getValidationStateForTicket,
LinearTicketItem rendering, selectedTicketId handling, and the
loadMoreTriggerRef placement are preserved).

In `@apps/frontend/src/renderer/components/linear/components/ValidationModal.tsx`:
- Line 36: Remove the unused import Textarea from ValidationModal.tsx: locate
the import line that reads "import { Textarea } from '../../ui/textarea';" and
delete it (or remove Textarea from the named import) so the component no longer
imports an unused symbol; verify no other references to Textarea exist in the
ValidationModal component (e.g., within the ValidationModal function or its JSX)
before committing.
- Around line 162-163: createTaskFromLinearTicket can return null on failure,
but the current handler calls onOpenChange(false) unconditionally which closes
the modal and hides failures; modify the submit flow in ValidationModal where
createTaskFromLinearTicket(ticketId, updatedValidation) is awaited to check its
return value, only call onOpenChange(false) when the result is a non-null
string, and handle the null case by keeping the modal open and surfacing an
error (e.g., set a local error state or trigger a toast/snackbar) so the user
sees the failure; reference the createTaskFromLinearTicket call and the
onOpenChange(false) invocation to locate the change.

In `@apps/frontend/src/renderer/components/linear/hooks/index.ts`:
- Around line 1-3: Remove the stale placeholder comment and replace it with an
accurate brief description (or delete it entirely) because the hooks
useLinearTickets and useLinearFiltering are already implemented; update the
top-of-file comment in the file that exports useLinearTickets and
useLinearFiltering so it no longer says "will be implemented in subtask-5-2" and
instead reflects the current state (e.g., "Exports implemented hooks:
useLinearTickets, useLinearFiltering").

In `@apps/frontend/src/renderer/components/linear/hooks/useLinearFiltering.ts`:
- Around line 76-81: The team filter branch in useLinearFiltering (check
currentFilters.teamId in useLinearFiltering.ts) is a non-functional placeholder
and should be clarified or removed; either (A) add a TODO with a link to a
tracking issue above the if-block and update the JSDoc for the hook to document
that team filtering is not yet supported, or (B) remove teamId from the
LinearFilters type and any setTeamFilter usages so callers cannot expect it to
workâ€”prefer the option that matches project policy (if keeping the field, ensure
setTeamFilter is a no-op with a clear TODO/JSDoc and link to the issue).
- Around line 49-56: The current code calls useLinearStore separately for
storeFilters, storeUpdateFilter, storeClearFilters and storeSetFilters even when
useStore is false, causing unnecessary subscriptions; replace the multiple
unconditional selectors with a single useLinearStore selector that returns all
required values (filters, updateFilter, clearFilters, setFilters) when useStore
is true and returns safe defaults (localFilters and no-op functions) when
useStore is false, and use a shallow comparison to avoid extra re-renders; then
use that single result to set the filters variable instead of the separate
store* selectors.
- Around line 150-155: Remove the unnecessary identity wrapper useCallback named
setSearchQueryCallback and replace its usages with the stable state setter
setSearchQuery directly; delete the setSearchQueryCallback declaration (the
useCallback block) and update any references to call setSearchQuery(query)
instead to simplify the code in useLinearFiltering.

In `@apps/frontend/src/renderer/components/linear/hooks/useLinearTickets.ts`:
- Around line 169-176: The effect that resets state on projectId change (the
useEffect block that sets hasLoadedRef.current, setHasMore, calls
useLinearStore.getState().clearTickets(), clearValidationResults(),
selectTicket(null), and resets currentFetchTicketIdRef.current) must also cancel
or ignore any in-flight async work; add a cleanup that either calls
AbortController.abort() for any ongoing fetches used by the hook or toggles a
cancelled flag/fetchId so callbacks (e.g., ticket fetch handlers and any
functions that use currentFetchTicketIdRef) early-return when cancelled, and
ensure any created AbortController or cancelled flag is stored (e.g., in a ref)
and aborted/marked in the effect's return to prevent processing stale results
when projectId changes rapidly.
- Around line 130-144: Replace the hardcoded English error strings passed to
useLinearStore.getState().setError and the local errorMessage with i18n
translation keys; locate the strings "Not connected to Linear" and "Failed to
check Linear connection" inside the error paths in useLinearTickets (the block
that handles connectionResult.data.error, connectionResult.error, and the catch
that sets errorMessage and setIsConnected) and call the app's translation helper
(e.g., t('linear.notConnected') or i18n.t('linear.failedCheck')) instead of raw
text so messages are localized.
- Around line 194-212: The fetchLinearTicket call in useLinearTickets.ts can
return null because fetchLinearTicket in linear-store.ts is a stub; update the
code to handle that case explicitly: after awaiting fetchLinearTicket(ticketId)
check for a null/undefined response and treat it as an error path (log a warning
via console.warn or process logger including ticketId, ensure
setIsLoadingTicket(false) runs for the matching currentFetchTicketIdRef.current,
and avoid assuming the store was updated), or alternatively implement the real
IPC/handler in linear-store.ts (replace the stub in fetchLinearTicket with the
actual IPC call that returns ticket details). Reference: useLinearTickets.ts
(currentFetchTicketIdRef, setIsLoadingTicket) and linear-store.ts
(fetchLinearTicket).
- Around line 113-150: fetchTicketsData takes an unused append flag causing
pagination to always replace tickets; forward the append boolean into
fetchLinearTickets (call fetchLinearTickets(append)) and update the store logic
(the setter used by fetchLinearTickets, e.g.,
useLinearStore.getState().setTickets or the fetchLinearTickets implementation)
to append when append === true (concat existing tickets with newly fetched ones)
and replace when false; alternatively, if pagination isn't supported, remove the
append parameter and all callers (e.g., loadMore) so the flag isn't misleading.

In `@apps/frontend/src/renderer/components/linear/LinearDashboard.tsx`:
- Around line 55-63: Replace the hardcoded English message in LinearDashboard's
empty-state block with an i18n key: call the translation function t(...) instead
of the literal "Try adjusting your filters or search terms", e.g.
t('linear.empty.adjustFilters') and add that key to your locale files; update
the EmptyState component usage in LinearDashboard.tsx to accept and pass the t
prop (same pattern as NotConnectedState) so EmptyState can render translated
text, and ensure the EmptyState component signature (prop name t) and any places
that render the message use t(...) instead of a hardcoded string.
- Around line 94-95: You're calling useLinearTickets twice; instead destructure
validationResults from the first call to avoid duplicate hook invocations and
extra re-renders. Locate the existing useLinearTickets(...) call (the one using
isActive and projectId: selectedProject?.id), add validationResults to its
destructuring (alongside whatever other returned values are already
destructured) and remove the second standalone call that only reads
validationResults so the component only invokes useLinearTickets once.
- Around line 323-327: The hardcoded "Loading..." string inside TooltipContent
should be replaced with an i18n call; update the conditional to use the
translator function t(...) instead of the literal (e.g.,
t("linear.shortcutHints.loading") or t("common.loading")) so the UI text is
localized, and add the corresponding key to the translation files; update the
code around TooltipContent and the isLoading expression to call t(...) for the
loading label.

In `@apps/frontend/src/renderer/lib/browser-mock.ts`:
- Around line 234-241: The Linear API mock is missing implementations for
validateLinearTicket, validateLinearTicketBatch,
updateLinearTicketWithValidation, and clearLinearCache used by linear-store.ts
and LinearDashboard.tsx; add async stub methods to the existing linear object
that return the same success-shaped responses as the other mocks (e.g., success
flags, data payloads/errors) so tests and renderer code can call them. Also
remove the hardcoded platform-specific executable paths (e.g.,
"/usr/local/bin/claude") and replace them with calls to the platform
abstraction's detection helpers (use the platform module functions already
available in the project) so the mock uses platform-aware paths instead of fixed
strings. Ensure the new symbol names match validateLinearTicket,
validateLinearTicketBatch, updateLinearTicketWithValidation, and
clearLinearCache so callers resolve correctly.

In `@apps/frontend/src/renderer/stores/__tests__/linear-store.test.ts`:
- Around line 400-440: Add a new test in the describe('getFilteredTickets')
block that verifies combined filters by creating tickets with varying status and
priority via createTestTicket, calling
useLinearStore.getState().setTickets(tickets), then applying both filters with
useLinearStore.getState().updateFilter('status', 'In Progress') and
updateFilter('priority', 2), and finally asserting
useLinearStore.getState().getFilteredTickets() returns only the expected ticket
(check length and id) to ensure getFilteredTickets correctly AND-combines
filters.
- Around line 39-75: The test helper createTestValidationResult currently
misaligns with the ValidationResult interface; update the returned object to use
the correct field names and required root fields: rename
contentAnalysis.description â†’ descriptionSummary, completenessValidation.score â†’
feasibilityScore and completenessValidation.validationNotes â†’
feasibilityReasoning, versionRecommendation.incrementType â†’ versionType and
versionRecommendation.rationale â†’ reasoning; add required root fields ticketId,
ticketIdentifier, validationTimestamp, cached (boolean), and status (one of
'pending'|'validating'|'complete'|'error') with sensible defaults; add
reason:string to each suggestedLabels item; remove the non-existent
taskProperties.acceptanceCriteria and remove root-level confidence and reasoning
(use status/inner fields instead); keep the ...overrides spread so tests can
override defaults.

In `@apps/frontend/src/renderer/stores/linear-store.ts`:
- Around line 92-99: The teamId branch in applyFilters is a no-op; either
implement the client-side filter or remove it. If you can filter client-side,
add logic inside applyFilters to return tickets.filter by comparing the ticket's
team identifier (e.g., ticket.team?.id or ticket.teamId on LinearTicket) to
filters.teamId; ensure you handle missing team data safely (undefined). If
client-side filtering isn't possible due to missing team info from the API,
delete the empty if (filters.teamId) block (and its placeholder comment) to
avoid misleading dead code and include a TODO comment referencing server-side
filtering in its place.
- Around line 384-391: The code uses a non-null assertion on currentResult (from
store.getValidationResult(ticketId)) when calling store.updateValidationResult;
instead, guard against currentResult being undefined: fetch currentResult with
store.getValidationResult(ticketId) and if it's undefined either return early or
construct a default validation result object (including fields like status and
error) before calling store.updateValidationResult(ticketId, ...); update the
calls around currentResult (the spots using currentResult! in
updateValidationResult) to use the guarded/constructed value to avoid runtime
errors.
- Around line 690-751: The function buildTaskDescriptionFromValidation currently
hardcodes user-facing markdown strings (e.g., "**Original Description:**", "**AI
Validation Summary:**", "*Summary:*", "*Requirements:*", "*Completeness:*",
"*Suggested Labels:*", "*Version Recommendation:*", "*Task Properties:*", etc.);
replace these literals with i18n keys and call the app's translation helper
(e.g., t('linear.task.originalDescription')) inside
buildTaskDescriptionFromValidation, or accept a translator function param and
use that to produce each label, keeping the markdown punctuation and
interpolation of ticket/validation fields intact; ensure defaults/fallbacks
exist for missing translations and update any usages of label fields
(label.name, label.reason) accordingly so generated task descriptions remain the
same shape but are translatable.
- Around line 262-281: The catch and error branches in fetchLinearTickets use
hardcoded messages; replace them with i18n translation keys using react-i18next
(e.g., call t('linear.fetchFailed') or similar) instead of literal strings, and
ensure you import/use the useTranslation hook or pass the t function into this
store so store.setError receives translated text; apply the same change pattern
to the other async functions validateLinearTicket, validateLinearTicketBatch,
fetchLinearTeams, fetchLinearProjects, updateLinearTicketWithValidation, and
createTaskFromLinearTicket so all user-facing error messages use t(...)
translation keys rather than hardcoded strings.
- Around line 363-373: The store is accessing store.selectedProjectId but
LinearState doesn't declare it, causing undefined; add a selectedProjectId?:
string | null (or string) property to the LinearState interface and initialize
it in the store's initial state (e.g., in the createLinearStore / initialState
object) to a sensible default (null or empty string) so the code that reads
projectId (used in the validation block) behaves correctly; update any related
setters/getters (e.g., setSelectedProjectId) to maintain the new state field.

In `@apps/frontend/src/shared/i18n/locales/en/common.json`:
- Around line 381-467: LinearTicketDetail.tsx references multiple missing
translation keys in the linear namespace causing raw keys to show; add the
following keys to the linear object in en/common.json: validated, notValidated,
description, noDescription, validateTicket, validating, validationComplete,
confidence, recommendedVersion, category, viewFullValidation and supply
appropriate English strings (e.g., "Validated", "Not validated", "Description",
"No description provided", "Validate ticket", "Validating...", "Validation
complete", "Confidence", "Recommended version", "Category", "View full
validation") so the component uses human-friendly text.

In `@apps/frontend/src/shared/i18n/locales/fr/common.json`:
- Around line 381-433: French translations use inconsistent capitalization;
update the string values to follow French sentence case (only capitalize the
first word and proper nouns) for the Linear section. Specifically, edit the
values for keys such as "notConnected", "connectPrompt", "runValidation",
"validationStarted", "analysisInProgress" (keep "IA" uppercase),
"analysisComplete", "validationInProgress", "waitingForChanges",
"validationComplete", "newChanges", "newChange", "oneNewChange", "runFollowup",
"previousValidation", "followupInProgress", "updateTicket", "createTask",
"updating", "creating", "ticketUpdated", "taskCreated", "updateFailed",
"createTaskFailed", "viewOnLinear" and similar entries to use sentence case
(e.g., "Linear non connectÃ©", "Valider le ticket", "Validation dÃ©marrÃ©e",
"Analyse IA en cours...", "nouveaux changements", "Mettre Ã  jour le ticket").
Ensure proper nouns like "Linear" and acronyms like "IA" remain capitalized.

In `@guides/linear-integration.md`:
- Line 129: Replace the unhyphenated compound adjective "high priority" in the
sentence starting with "**Patch increment** (e.g., 2.7.4 â†’ 2.7.5): Bug fixes,
especially critical/high priority" with the hyphenated form "high-priority" so
the phrase reads "Bug fixes, especially critical/high-priority" to use correct
compound-adjective grammar.
````

</details>

<!-- This is an auto-generated comment by CodeRabbit for review status -->

---

## Implementation Notes

*Status: SKIPPED*

**Reason:** Review state: COMMENTED

