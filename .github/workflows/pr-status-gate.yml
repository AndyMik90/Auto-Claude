name: PR Status Gate

on:
  workflow_run:
    workflows: [CI, Lint, Quality Security]
    types: [completed]

  issue_comment:
    types: [created, edited]

  pull_request:
    types: [synchronize]

concurrency:
  group: pr-status-gate-${{ github.event.workflow_run.pull_requests[0].number || github.event.issue.number || github.event.pull_request.number || github.run_id }}
  cancel-in-progress: true

permissions:
  pull-requests: write
  checks: read

env:
  # Shared configuration - single source of truth
  REQUIRED_CHECKS: |
    CI / test-frontend
    CI / test-python (3.12)
    CI / test-python (3.13)
    Lint / python
    Quality Security / CodeQL (javascript-typescript)
    Quality Security / CodeQL (python)
    Quality Security / Python Security (Bandit)
    Quality Security / Security Summary

jobs:
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # JOB 1: CI STATUS (triggered by workflow_run)
  # Updates CI status labels when monitored workflows complete
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  update-ci-status:
    name: Update CI Status
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run' && github.event.workflow_run.pull_requests[0] != null
    timeout-minutes: 5

    steps:
      - name: Check all required checks and update label
        uses: actions/github-script@v7
        env:
          REQUIRED_CHECKS: ${{ env.REQUIRED_CHECKS }}
        with:
          retries: 3
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            const STATUS_LABELS = Object.freeze({
              CHECKING: 'üîÑ Checking',
              PASSED: '‚úÖ Ready for Review',
              FAILED: '‚ùå Checks Failed'
            });

            const REQUIRED_CHECKS = process.env.REQUIRED_CHECKS
              .split('\n')
              .map(s => s.trim())
              .filter(Boolean);

            async function fetchCheckRuns(sha) {
              const { owner, repo } = context.repo;
              try {
                const { data } = await github.rest.checks.listForRef({
                  owner, repo, ref: sha, per_page: 100
                });
                return data.check_runs;
              } catch (error) {
                core.warning(`Failed to fetch check runs: ${error.message}`);
                return null;
              }
            }

            function analyzeChecks(checkRuns) {
              const results = [];
              let allComplete = true;
              let anyFailed = false;

              for (const checkName of REQUIRED_CHECKS) {
                const check = checkRuns.find(c => c.name === checkName);

                if (!check) {
                  results.push({ name: checkName, status: '‚è≥ Pending', complete: false });
                  allComplete = false;
                } else if (check.status !== 'completed') {
                  results.push({ name: checkName, status: 'üîÑ Running', complete: false });
                  allComplete = false;
                } else if (check.conclusion === 'success') {
                  results.push({ name: checkName, status: '‚úÖ Passed', complete: true });
                } else if (check.conclusion === 'skipped') {
                  results.push({ name: checkName, status: '‚è≠Ô∏è Skipped', complete: true, skipped: true });
                } else {
                  results.push({ name: checkName, status: '‚ùå Failed', complete: true, failed: true });
                  anyFailed = true;
                }
              }
              return { allComplete, anyFailed, results };
            }

            async function updateStatusLabels(prNumber, newLabel) {
              const { owner, repo } = context.repo;
              const allLabels = Object.values(STATUS_LABELS);

              for (const label of allLabels) {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: label });
                } catch (e) { /* ignore 404 */ }
              }

              try {
                await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [newLabel] });
              } catch (e) {
                if (e.status !== 404) throw e;
                core.warning(`Label '${newLabel}' does not exist`);
              }
            }

            // Main logic
            const prNumber = context.payload.workflow_run.pull_requests[0].number;
            const headSha = context.payload.workflow_run.head_sha;
            const triggerWorkflow = context.payload.workflow_run.name;

            console.log(`PR #${prNumber} - Triggered by: ${triggerWorkflow}, SHA: ${headSha.slice(0, 8)}`);

            const checkRuns = await fetchCheckRuns(headSha);
            if (!checkRuns) return;

            console.log(`Found ${checkRuns.length} check runs`);
            const { allComplete, anyFailed, results } = analyzeChecks(checkRuns);

            for (const r of results) {
              console.log(`  ${r.status} ${r.name}`);
            }

            if (!allComplete) {
              const pending = results.filter(r => !r.complete).length;
              console.log(`‚è≥ ${pending}/${REQUIRED_CHECKS.length} checks pending`);
              return;
            }

            const newLabel = anyFailed ? STATUS_LABELS.FAILED : STATUS_LABELS.PASSED;
            await updateStatusLabels(prNumber, newLabel);

            const passedCount = results.filter(r => r.status === '‚úÖ Passed').length;
            const failedCount = results.filter(r => r.failed).length;

            if (anyFailed) {
              console.log(`‚ùå PR #${prNumber}: ${failedCount} check(s) failed`);
            } else {
              console.log(`‚úÖ PR #${prNumber}: Ready for review (${passedCount}/${REQUIRED_CHECKS.length} passed)`);
            }

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # JOB 2: /check-status COMMAND
  # Manual status check - anyone can trigger by commenting /check-status
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  check-status-command:
    name: Check Status Command
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issue_comment' &&
      github.event.issue.pull_request &&
      contains(github.event.comment.body, '/check-status')
    timeout-minutes: 5

    steps:
      - name: Run status check and post report
        uses: actions/github-script@v7
        env:
          REQUIRED_CHECKS: ${{ env.REQUIRED_CHECKS }}
        with:
          retries: 3
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            const STATUS_LABELS = Object.freeze({
              CHECKING: 'üîÑ Checking',
              PASSED: '‚úÖ Ready for Review',
              FAILED: '‚ùå Checks Failed'
            });

            const REVIEW_LABELS = Object.freeze([
              'Missing AC Approval',
              'AC: Approved',
              'AC: Changes Requested',
              'AC: Rejected',
              'AC: Needs Re-review'
            ]);

            const REQUIRED_CHECKS = process.env.REQUIRED_CHECKS
              .split('\n')
              .map(s => s.trim())
              .filter(Boolean);

            const { owner, repo } = context.repo;
            const prNumber = context.payload.issue.number;
            const requestedBy = context.payload.comment.user.login;

            // Get PR details
            const { data: pr } = await github.rest.pulls.get({
              owner, repo, pull_number: prNumber
            });
            const headSha = pr.head.sha;

            console.log(`PR #${prNumber} - /check-status by @${requestedBy}, SHA: ${headSha.slice(0, 8)}`);

            // Fetch check runs
            const { data: checksData } = await github.rest.checks.listForRef({
              owner, repo, ref: headSha, per_page: 100
            });

            const checkRuns = checksData.check_runs;
            console.log(`Found ${checkRuns.length} check runs`);

            // Analyze results
            const results = [];
            let allComplete = true;
            let anyFailed = false;

            for (const checkName of REQUIRED_CHECKS) {
              const check = checkRuns.find(c => c.name === checkName);

              if (!check) {
                results.push({ name: checkName, emoji: '‚è≥', complete: false });
                allComplete = false;
              } else if (check.status !== 'completed') {
                results.push({ name: checkName, emoji: 'üîÑ', complete: false });
                allComplete = false;
              } else if (check.conclusion === 'success') {
                results.push({ name: checkName, emoji: '‚úÖ', complete: true });
              } else if (check.conclusion === 'skipped') {
                results.push({ name: checkName, emoji: '‚è≠Ô∏è', complete: true, skipped: true });
              } else {
                results.push({ name: checkName, emoji: '‚ùå', complete: true, failed: true });
                anyFailed = true;
              }
            }

            // Get current labels
            const { data: currentLabels } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: prNumber
            });
            const labelNames = currentLabels.map(l => l.name);
            const currentStatusLabel = Object.values(STATUS_LABELS).find(l => labelNames.includes(l)) || 'None';
            const currentReviewLabel = REVIEW_LABELS.find(l => labelNames.includes(l)) || 'None';

            // Update label if all checks complete
            let newStatusLabel = STATUS_LABELS.CHECKING;
            let statusChanged = false;

            if (allComplete) {
              newStatusLabel = anyFailed ? STATUS_LABELS.FAILED : STATUS_LABELS.PASSED;

              if (newStatusLabel !== currentStatusLabel) {
                statusChanged = true;
                for (const label of Object.values(STATUS_LABELS)) {
                  try {
                    await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: label });
                  } catch (e) { /* ignore */ }
                }
                await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [newStatusLabel] });
              }
            }

            // Build status report
            const passedCount = results.filter(r => r.emoji === '‚úÖ').length;
            let statusEmoji = 'üîÑ';
            if (allComplete && !anyFailed) statusEmoji = '‚úÖ';
            else if (allComplete && anyFailed) statusEmoji = '‚ùå';

            const checksTable = results.map(r => `| ${r.emoji} | ${r.name} |`).join('\n');

            const lines = [
              `## ${statusEmoji} PR Status Report`,
              '',
              `| Label | Value |`,
              `|-------|-------|`,
              `| CI Status | ${newStatusLabel} |`,
              `| AC Review | ${currentReviewLabel} |`,
              ''
            ];

            if (statusChanged) {
              lines.push(`> Status updated: \`${currentStatusLabel}\` ‚Üí \`${newStatusLabel}\``);
              lines.push('');
            }

            lines.push(`### CI Checks (${passedCount}/${REQUIRED_CHECKS.length} passed)`);
            lines.push('');
            lines.push('| Status | Check |');
            lines.push('|--------|-------|');
            lines.push(checksTable);
            lines.push('');
            lines.push('---');
            lines.push(`<sub>Triggered by \`/check-status\` from @${requestedBy}</sub>`);

            await github.rest.issues.createComment({
              owner, repo, issue_number: prNumber, body: lines.join('\n')
            });

            console.log(`‚úÖ Posted status report to PR #${prNumber}`);

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # JOB 3: AUTO-CLAUDE REVIEW
  # Processes Auto-Claude review comments from trusted sources
  # Security: Only bots and collaborators can update labels
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  update-review-status:
    name: Update Review Status
    runs-on: ubuntu-latest
    if: |
      github.event_name == 'issue_comment' &&
      github.event.issue.pull_request &&
      !contains(github.event.comment.body, '/check-status')
    timeout-minutes: 5

    steps:
      - name: Check for Auto-Claude review
        uses: actions/github-script@v7
        with:
          retries: 3
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            // Security configuration
            const TRUSTED_BOT_ACCOUNTS = Object.freeze([
              'github-actions[bot]',
              'github-actions',
              'auto-claude[bot]',
              'auto-claude',
              'AutoClaudeBot'
            ]);

            const TRUSTED_AUTHOR_ASSOCIATIONS = Object.freeze([
              'COLLABORATOR',
              'MEMBER',
              'OWNER'
            ]);

            const IDENTIFIER_PATTERNS = Object.freeze([
              'ü§ñ Auto Claude PR Review',
              'Auto Claude Review',
              'Auto-Claude Review'
            ]);

            const VERDICTS = Object.freeze({
              APPROVED: {
                patterns: ['Auto Claude Review - APPROVED', '‚úÖ Auto Claude Review - APPROVED'],
                regex: /Merge Verdict:.*(?:‚úÖ|üü¢).*(?:APPROVED|READY TO MERGE)/i,
                label: 'AC: Approved'
              },
              CHANGES_REQUESTED: {
                patterns: ['NEEDS REVISION', 'Needs Revision'],
                regex: /Merge Verdict:.*üü†/,
                label: 'AC: Changes Requested'
              },
              REJECTED: {
                patterns: ['REJECTED'],
                regex: /Merge Verdict:.*üî¥/,
                label: 'AC: Rejected'
              },
              RE_REVIEW: {
                patterns: ['Re-review', 're-review', 'RE-REVIEW'],
                regex: null,
                label: 'AC: Needs Re-review'
              }
            });

            const REVIEW_LABELS = Object.freeze([
              'Missing AC Approval',
              'AC: Approved',
              'AC: Changes Requested',
              'AC: Rejected',
              'AC: Needs Re-review',
              'AC: Reviewed'
            ]);

            // Helper functions
            function isTrustedBot(username) {
              return TRUSTED_BOT_ACCOUNTS.some(t => username.toLowerCase() === t.toLowerCase());
            }

            function isTrustedAssociation(assoc) {
              return TRUSTED_AUTHOR_ASSOCIATIONS.includes(assoc);
            }

            function isAutoClaudeComment(body) {
              return IDENTIFIER_PATTERNS.some(p => body.includes(p));
            }

            function parseVerdict(body) {
              const safeBody = body.slice(0, 5000);
              for (const [key, config] of Object.entries(VERDICTS)) {
                const patternMatch = config.patterns.some(p => safeBody.includes(p));
                const regexMatch = config.regex && config.regex.test(safeBody);
                if (patternMatch || regexMatch) {
                  return { verdict: key, label: config.label };
                }
              }
              return null;
            }

            async function updateReviewLabels(prNumber, newLabel) {
              const { owner, repo } = context.repo;

              for (const label of REVIEW_LABELS) {
                try {
                  await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: label });
                  console.log(`  Removed: ${label}`);
                } catch (e) { /* ignore 404 */ }
              }

              try {
                await github.rest.issues.addLabels({ owner, repo, issue_number: prNumber, labels: [newLabel] });
                console.log(`  Added: ${newLabel}`);
              } catch (e) {
                if (e.status === 404) {
                  core.warning(`Label '${newLabel}' does not exist`);
                } else {
                  throw e;
                }
              }
            }

            // Main logic
            const prNumber = context.payload.issue.number;
            const comment = context.payload.comment;
            const commenter = comment.user.login;
            const authorAssociation = comment.author_association;
            const body = comment.body || '';

            console.log(`PR #${prNumber} - Comment by: ${commenter} (${authorAssociation})`);

            // Security checks
            const isBot = isTrustedBot(commenter);
            const isCollaborator = isTrustedAssociation(authorAssociation);
            const isACComment = isAutoClaudeComment(body);

            console.log(`  Trusted bot: ${isBot}, Collaborator: ${isCollaborator}, AC comment: ${isACComment}`);

            if (!isBot && !isCollaborator) {
              console.log('Skipping: Not a trusted bot or collaborator');
              return;
            }

            if (!isACComment) {
              console.log('Skipping: Not an Auto-Claude comment');
              return;
            }

            const verdictResult = parseVerdict(body);
            if (!verdictResult) {
              console.log('Skipping: Could not parse verdict');
              return;
            }

            console.log(`Verdict: ${verdictResult.verdict} ‚Üí ${verdictResult.label}`);
            await updateReviewLabels(prNumber, verdictResult.label);
            console.log(`‚úÖ PR #${prNumber} review status updated`);

  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  # JOB 4: RE-REVIEW ON PUSH
  # When new commits pushed after AC approval, require re-review
  # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
  require-re-review:
    name: Require Re-review on Push
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' && github.event.action == 'synchronize'
    timeout-minutes: 5

    steps:
      - name: Check and reset AC approval if needed
        uses: actions/github-script@v7
        with:
          retries: 3
          retry-exempt-status-codes: 400,401,403,404,422
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;
            const pusher = context.payload.sender.login;

            console.log(`PR #${prNumber} - New commits by: ${pusher}`);

            // Get current labels
            const { data: labels } = await github.rest.issues.listLabelsOnIssue({
              owner, repo, issue_number: prNumber
            });
            const labelNames = labels.map(l => l.name);

            // Check if PR was approved
            const wasApproved = labelNames.includes('AC: Approved');

            if (!wasApproved) {
              console.log('PR was not AC-approved, no action needed');
              return;
            }

            console.log('PR was AC-approved, resetting to require re-review');

            // Remove AC: Approved
            try {
              await github.rest.issues.removeLabel({
                owner, repo, issue_number: prNumber, name: 'AC: Approved'
              });
              console.log('  Removed: AC: Approved');
            } catch (e) { /* ignore */ }

            // Add AC: Needs Re-review
            try {
              await github.rest.issues.addLabels({
                owner, repo, issue_number: prNumber, labels: ['AC: Needs Re-review']
              });
              console.log('  Added: AC: Needs Re-review');
            } catch (e) {
              if (e.status === 404) {
                core.warning("Label 'AC: Needs Re-review' does not exist");
              } else {
                throw e;
              }
            }

            // Reset CI status
            const statusLabels = ['üîÑ Checking', '‚úÖ Ready for Review', '‚ùå Checks Failed'];
            for (const label of statusLabels) {
              try {
                await github.rest.issues.removeLabel({ owner, repo, issue_number: prNumber, name: label });
              } catch (e) { /* ignore */ }
            }

            try {
              await github.rest.issues.addLabels({
                owner, repo, issue_number: prNumber, labels: ['üîÑ Checking']
              });
              console.log('  Reset status: üîÑ Checking');
            } catch (e) { /* ignore */ }

            // Post notification comment
            const commentLines = [
              '## üîÑ Re-review Required',
              '',
              'New commits were pushed after Auto-Claude approval.',
              '',
              '| Previous | Current |',
              '|----------|---------|',
              '| `AC: Approved` | `AC: Needs Re-review` |',
              '',
              'Please run Auto-Claude review again or request a manual review.',
              '',
              '---',
              `<sub>Triggered by push from @${pusher}</sub>`
            ];

            await github.rest.issues.createComment({
              owner, repo, issue_number: prNumber, body: commentLines.join('\n')
            });

            console.log(`‚úÖ Posted re-review notification to PR #${prNumber}`);
